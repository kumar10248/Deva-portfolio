import { BlogLayout } from "@/components/BlogLayout";

import { CodeWindow } from "@/components/CodeWindow";

export const meta = {
  date: "2024-08-18",
  title: "Writing Clean Code With React",
  description:
    "Effective and efficient ways to write clean code with React while keeping in mind the performance and maintainability of the codebase.",
  image:
    "https://images.unsplash.com/photo-1542831371-29b0f74f9713?q=80&w=3540&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
  tags: ["Clean Code"],
};

export default (props) => <BlogLayout meta={meta} {...props} />;

Writing clean code is not just about making your code work—it's about making it **readable, maintainable, and scalable**. When working with React, following clean code principles becomes even more important because React applications can quickly grow complex.

In this article, I'll share practical tips and best practices for writing clean React code that your team (and future you) will thank you for.

## Why Clean Code Matters

Clean code is easier to understand, debug, and modify. When you write clean code, you're not just writing for the computer—you're writing for other developers who will read your code later. This includes your future self!

Here are the key benefits:

- **Easier debugging** - When something breaks, you can quickly find the problem
- **Faster onboarding** - New team members can understand the codebase quickly
- **Better collaboration** - Your team can work together more efficiently
- **Fewer bugs** - Clear code has fewer hidden surprises

## 1. Use Meaningful Component Names

Your component names should clearly describe what they do. Avoid generic names like `Component1` or `MyComponent`.

<CodeWindow title="Bad Example">
```jsx
function Card() {
  return <div>User info here</div>;
}
```
</CodeWindow>

<CodeWindow title="Good Example">
```jsx
function UserProfileCard() {
  return <div>User info here</div>;
}
```
</CodeWindow>

## 2. Keep Components Small and Focused

Each component should do one thing and do it well. If your component is getting too long (more than 200-300 lines), it's probably time to break it down.

<CodeWindow title="Bad Example">
```jsx
function Dashboard() {
  // 500 lines of code handling everything
  // user data, charts, notifications, settings...
}
```
</CodeWindow>

<CodeWindow title="Good Example">
```jsx
function Dashboard() {
  return (
    <div>
      <UserHeader />
      <ChartsSection />
      <NotificationPanel />
      <SettingsWidget />
    </div>
  );
}
```
</CodeWindow>

## 3. Use Custom Hooks for Reusable Logic

Instead of repeating the same logic in multiple components, extract it into a custom hook.

<CodeWindow title="useUserData.js">
```jsx
// Custom hook
function useUserData(userId) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser(userId).then(data => {
      setUser(data);
      setLoading(false);
    });
  }, [userId]);

  return { user, loading };
}

// Use it in any component
function UserProfile({ userId }) {
  const { user, loading } = useUserData(userId);
  
  if (loading) return <Spinner />;
  return <div>{user.name}</div>;
}
```
</CodeWindow>

## 4. Avoid Prop Drilling

When you need to pass data through many levels of components, consider using Context API or state management libraries like Redux or Zustand.

<CodeWindow title="Bad Example - Prop Drilling">
```jsx
<App>
  <Header user={user} />
    <Nav user={user} />
      <Profile user={user} />
</App>
```
</CodeWindow>

<CodeWindow title="Good Example - Context API">
```jsx
<UserContext.Provider value={user}>
  <App>
    <Header />
    <Nav />
    <Profile />
  </App>
</UserContext.Provider>
```
</CodeWindow>

## 5. Write Descriptive Props

Props should have clear names that explain what they do. Avoid single letters or abbreviations.

<CodeWindow title="Bad Example">
```jsx
<Button clk={handleClick} txt="Submit" />
```
</CodeWindow>

<CodeWindow title="Good Example">
```jsx
<Button onClick={handleClick} text="Submit" />
```
</CodeWindow>

## 6. Handle Loading and Error States

Always consider what happens when data is loading or when errors occur.

<CodeWindow title="ProductList.jsx">
```jsx
function ProductList() {
  const { products, loading, error } = useProducts();

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;
  if (!products.length) return <EmptyState />;

  return (
    <div>
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```
</CodeWindow>

## 7. Use Constants for Magic Values

Don't hardcode values throughout your code. Use constants with descriptive names.

<CodeWindow title="Bad Example">
```jsx
if (user.role === 2) {
  // show admin panel
}
```
</CodeWindow>

<CodeWindow title="Good Example">
```jsx
const USER_ROLES = {
  USER: 1,
  ADMIN: 2,
  MODERATOR: 3
};

if (user.role === USER_ROLES.ADMIN) {
  // show admin panel
}
```
</CodeWindow>

## 8. Format Your Code Consistently

Use tools like Prettier and ESLint to maintain consistent formatting across your codebase. This removes debates about code style and makes everything look uniform.

## Example: A Clean React Component

<CodeWindow title="UserDashboard.tsx">
```TSX
import React, { useState, useEffect } from "react";
import { useUser } from "@/hooks/useUser";
import { LoadingSpinner } from "@/components/LoadingSpinner";
import { ErrorMessage } from "@/components/ErrorMessage";

// Clean, focused component with clear responsibility
export function UserDashboard({ userId }) {
  const { user, loading, error } = useUser(userId);

  // Early returns for different states
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;
  if (!user) return <div>User not found</div>;

  // Main render - clean and readable
  return (
    <div className="dashboard">
      <h1>Welcome, {user.name}!</h1>
      <div className="stats">
        <StatCard label="Projects" value={user.projects} />
        <StatCard label="Tasks" value={user.tasks} />
        <StatCard label="Messages" value={user.messages} />
      </div>
    </div>
  );
}

// Small, reusable component
function StatCard({ label, value }) {
  return (
    <div className="stat-card">
      <span className="label">{label}</span>
      <span className="value">{value}</span>
    </div>
  );
}
```
</CodeWindow>

## Conclusion

Writing clean React code is a skill that improves with practice. Start by following these principles:

1. **Name things clearly** - Use descriptive names for components, functions, and variables
2. **Keep it simple** - Break down complex components into smaller ones
3. **Be consistent** - Follow the same patterns throughout your codebase
4. **Think about others** - Write code that's easy for your team to understand
5. **Use the right tools** - Leverage ESLint, Prettier, and TypeScript

Remember: **Clean code is not about being perfect—it's about being clear and maintainable.** Your future self will thank you for taking the extra time to write clean, readable code today.
